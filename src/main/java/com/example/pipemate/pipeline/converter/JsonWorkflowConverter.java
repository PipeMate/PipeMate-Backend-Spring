package com.example.pipemate.pipeline.converter;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.NullNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import org.yaml.snakeyaml.DumperOptions;
import org.yaml.snakeyaml.Yaml;
import org.yaml.snakeyaml.nodes.Node;
import org.yaml.snakeyaml.nodes.Tag;
import org.yaml.snakeyaml.representer.Representer;

import java.io.StringWriter;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

@Component
@RequiredArgsConstructor
@Slf4j
public class JsonWorkflowConverter {

    private final ObjectMapper objectMapper;

    /**
     * JSON Map을 YAML 문자열로 변환
     */
    public String convertJsonToYaml(Map<String, Object> jsonData, String workflowName) {
        try {
            log.info("Starting YAML conversion");

            DumperOptions options = new DumperOptions();
            options.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);
            options.setDefaultScalarStyle(DumperOptions.ScalarStyle.PLAIN);
            options.setLineBreak(DumperOptions.LineBreak.UNIX);
            options.setIndent(2);
            options.setIndicatorIndent(0);
            options.setIndentWithIndicator(false);

            Representer representer = new Representer(options) {
                @Override
                protected Node representMapping(Tag tag, Map<?, ?> mapping, DumperOptions.FlowStyle flowStyle) {
                    if (mapping.isEmpty()) {
                        return super.representMapping(tag, mapping, DumperOptions.FlowStyle.FLOW);
                    }
                    return super.representMapping(tag, mapping, flowStyle);
                }
            };

            Yaml yaml = new Yaml(representer, options);
            StringWriter writer = new StringWriter();
            yaml.dump(jsonData, writer);

            String header = "# This workflow was automatically generated by PipeMate\n"
                    + "# Workflow name: " + workflowName + "\n"
                    + "# Generated at: " + java.time.LocalDateTime.now() + "\n\n";

            return header + writer.toString();

        } catch (Exception e) {
            log.error("Error during YAML conversion", e);
            throw new RuntimeException("Failed to convert to YAML: " + e.getMessage(), e);
        }
    }

    /**
     * JSON 블록을 GitHub Actions workflow JSON 구조로 변환
     */
    public Map<String, Object> convertToWorkflowJson(List<JsonNode> inputJsonBlocks) {
        try {
            Map<String, Object> root = new LinkedHashMap<>();
            List<Map<String, Object>> steps = new ArrayList<>();
            String jobId = null;

            log.info("Starting JSON conversion process with {} blocks", inputJsonBlocks.size());

            for (JsonNode block : inputJsonBlocks) {
                String type = block.path("type").asText(null);
                JsonNode config = block.path("config");

                if (type == null) {
                    // GitHub 액션 uses 직접 지정 방식
                    if (block.has("uses") && block.has("with")) {
                        Map<String, Object> step = new LinkedHashMap<>();
                        step.put("name", block.get("name").asText());
                        step.put("uses", block.get("uses").asText());
                        step.put("with", objectMapper.convertValue(block.get("with"), Map.class));
                        steps.add(step);
                        continue;
                    }
                    log.warn("Unknown block without type: {}", block.toPrettyString());
                    continue;
                }

                switch (type) {
                    case "trigger":
                        root.put("name", config.path("name").asText());

                        Map<String, Object> onMap = new LinkedHashMap<>();
                        JsonNode onNode = config.get("on");

                        // workflow_dispatch: 빈 맵
                        if (onNode.has("workflow_dispatch")) {
                            onMap.put("workflow_dispatch", new LinkedHashMap<>()); // {}
                        }

                        // push:
                        if (onNode.has("push")) {
                            Map<String, Object> pushMap = new LinkedHashMap<>();
                            List<String> branches = new ArrayList<>();
                            for (JsonNode branch : onNode.get("push").get("branches")) {
                                branches.add(branch.asText());
                            }
                            pushMap.put("branches", branches);
                            onMap.put("push", pushMap);
                        }

                        // pull_request:
                        if (onNode.has("pull_request")) {
                            Map<String, Object> prMap = new LinkedHashMap<>();
                            List<String> branches = new ArrayList<>();
                            for (JsonNode branch : onNode.get("pull_request").get("branches")) {
                                branches.add(branch.asText());
                            }
                            prMap.put("branches", branches);
                            onMap.put("pull_request", prMap);
                        }

                        // Map → ObjectNode 변환
                        ObjectNode onNodeYaml = objectMapper.convertValue(onMap, ObjectNode.class);
                        root.put("on", onMap);
                        break;



                    case "job":
                        if (config.has("jobs") && config.get("jobs").isObject()) {
                            jobId = config.get("jobs").fieldNames().next();
                        }
                        break;

                    case "step":
                        Map<String, Object> step = objectMapper.convertValue(config, Map.class);
                        steps.add(step);
                        break;

                    default:
                        log.warn("Unknown type: {}", type);
                        break;
                }
            }

            if (jobId == null) {
                jobId = "ci-pipeline";
            }

            Map<String, Object> jobConfig = new LinkedHashMap<>();
            jobConfig.put("runs-on", "ubuntu-latest");
            jobConfig.put("steps", steps);

            Map<String, Object> jobs = new LinkedHashMap<>();
            jobs.put(jobId, jobConfig);

            root.put("jobs", jobs);

            return root;
        } catch (Exception e) {
            log.error("Error during JSON conversion", e);
            throw new RuntimeException("Failed to convert JSON workflow: " + e.getMessage(), e);
        }
    }

}
